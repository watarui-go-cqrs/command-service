package repository

import (
	"command-service/command/domain/models/products"
	"command-service/command/errs"
	"command-service/command/infra/sqlboiler/handler"
	"command-service/command/infra/sqlboiler/models"
	"context"
	"database/sql"
	"fmt"
	"log"

	"github.com/aarondl/sqlboiler/v4/boil"
	"github.com/aarondl/sqlboiler/v4/queries/qm"
)

type productRepositorySQLBoiler struct{}

func NewProductRepositorySQLBoiler() products.ProductRepository {
	models.AddProductHook(boil.AfterInsertHook, ProductAfterInsertHook)
	models.AddProductHook(boil.AfterUpdateHook, ProductAfterUpdateHook)
	models.AddProductHook(boil.AfterDeleteHook, ProductAfterDeleteHook)
	return &productRepositorySQLBoiler{}
}

func (r *productRepositorySQLBoiler) Exists(ctx context.Context, tran *sql.Tx, product *products.Product) error {
	cond := models.ProductWhere.Name.EQ(product.Name().Value())
	if exists, err := models.Products(cond).Exists(ctx, tran); err != nil {
		return handler.DBErrHandler(err)
	} else if !exists {
		return nil
	} else {
		return errs.NewCRUDError(fmt.Sprintf("product %s already exists", product.Name().Value()))
	}
}

func (r *productRepositorySQLBoiler) Create(ctx context.Context, tran *sql.Tx, product *products.Product) error {
	model := &models.Product{
		ID:         0, // ID will be auto-generated by the database
		ObjID:      product.Id().Value(),
		Name:       product.Name().Value(),
		Price:      int(product.Price().Value()),
		CategoryID: product.Category().Id().Value(),
	}

	if err := model.Insert(ctx, tran, boil.Whitelist("obj_id", "name", "price", "category_id")); err != nil {
		return handler.DBErrHandler(err)
	}

	return nil
}

func (rep *productRepositorySQLBoiler) UpdateById(ctx context.Context, tran *sql.Tx, product *products.Product) error {
	model, err := models.Products(qm.Where("obj_id = ?", product.Id().Value())).One(ctx, tran)
	if model == nil {
		return errs.NewCRUDError(fmt.Sprintf("Failed to find product with ID: %s", product.Id().Value()))
	}
	if err != nil {
		return handler.DBErrHandler(err)
	}
	model.ObjID = product.Id().Value()
	model.Name = product.Name().Value()
	model.Price = int(product.Price().Value())

	if _, err = model.Update(ctx, tran, boil.Whitelist("obj_id", "name", "price")); err != nil {
		return handler.DBErrHandler(err)
	}
	return nil
}

func (rep *productRepositorySQLBoiler) DeleteById(ctx context.Context, tran *sql.Tx, id *products.ProductId) error {
	model, err := models.Products(qm.Where("obj_id = ?", id.Value())).One(ctx, tran)
	if model == nil {
		return errs.NewCRUDError(fmt.Sprintf("Failed to find product with ID: %s", id.Value()))
	}
	if err != nil {
		return handler.DBErrHandler(err)
	}

	if _, err = model.Delete(ctx, tran); err != nil {
		return handler.DBErrHandler(err)
	}
	return nil
}

func ProductAfterInsertHook(ctx context.Context, exec boil.ContextExecutor, m *models.Product) error {
	log.Printf("ProductAfterInsertHook: Product with ID: %s and Name: %s was inserted", m.ObjID, m.Name)
	return nil
}

func ProductAfterUpdateHook(ctx context.Context, exec boil.ContextExecutor, m *models.Product) error {
	log.Printf("ProductAfterUpdateHook: Product with ID: %s and Name: %s was updated", m.ObjID, m.Name)
	return nil
}

func ProductAfterDeleteHook(ctx context.Context, exec boil.ContextExecutor, m *models.Product) error {
	log.Printf("ProductAfterDeleteHook: Product with ID: %s and Name: %s was deleted", m.ObjID, m.Name)
	return nil
}
